# 前言
iOS的组件化这块在去年3月起就有很多大神们讨论过，不过由于之前我们的项目结构比较简单，再加上用的swift做的开发，也没有去尝试做这块。直到前段时间公司准备用OC重构项目以符合新需求，于是于组内的小伙伴们研究了一下新项目的架构选型，经过一番讨论，决定使用组件化的架构。大约2周过后，组件化基本完成，决定写篇博客记录下我们组件化的过程，给想对项目做组件化的同学们做一个参考。

# 一、什么是组件化
想要做组件化的前提当然得知道什么是组件化。顾名思义，组件化就是将APP拆分成各个`组件`（或者说`模块`也行），同时解除这些模块之间的耦合，然后通过`主工程`将项目所需要的`组件`组合起来。这样组件化过后的项目就变成了很多小模块，如果新项目中有类似的需求，直接将模块引入稍作修改就能使用了。

这种设计是不是很像引入`三方库`做快速开发？其实制作组件的过程就相当于做`二方库`。因此常见的组件化方案大多都是使用`cocoapods`做依赖管理。

# 二、组件化的优缺点
组件化的优点：

1. 组件可独立运行，提高的代码的复用性，组件化的颗粒度越细，可复用度就越高。
2. 当组件库的数量足够庞大时，项目只需要组合组件即可完成大部分的开发工作。
3. 组件化后项目的代码结构更加清晰，追踪问题、修复bug、增加需求更方便
4. 不同业务组件相互独立，明确团队开发的业务边界，增加团队协作效率

组件化的缺点：

1. 增加开发人员的学习成本
2. 增加了代码的冗余，组件化颗粒度越细，中间代码越多
3. 增加了项目的复杂度，复杂度越高越容易出问题

总体上组件化对于项目的开发来说是利大于弊的，当然如果你的项目非常简单的话就没必要做这些了。

# 三、常见的组件化中间件方案的选择
项目在做组件化时必然要对各个组件之间做解耦。因为如果组件之间的耦合没有被剔除，想要使用某个组件的话就有可能会引用与所需业务无关的其他组件，这也就是[casatwy大神](http://casatwy.com)常说的`拔萝卜带出泥`。但是耦合这东西本身就是天然存在的，没有耦合、没有依赖本来就无法形成一个项目，我们能做到的只有尽量避免不必要的耦合带来的麻烦。

想要达到每个组件之间`相对低耦合`，比较常用的方案就是断掉`横向依赖`，使用`中间人模式`将依赖下沉至`中间件`。想想cocoapods是不是也类似这种模式？通过pod统一管理所有的三方库，然后项目持有`Pod`这个`Target`就可以使用所有的三方库了。

![组件化之前的项目依赖关系](http://upload-images.jianshu.io/upload_images/2015365-58a8644194bde836.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![组件化之后的项目依赖关系](http://upload-images.jianshu.io/upload_images/2015365-a23aa63f527d60b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当然这种模式也有缺点，太过于集中、随着组件的增加，这个中间件会越来越臃肿，最后变成中间件自身难以维护的情况。不过iOS项目中很少出现非常庞大的架构，一般来说不会造成瓶颈。另外，在这种组件化的中间件中，有一个非常重要的特性，那就是必须实现组件对中间件的`单向依赖`。原因引用casatwy大神的一句话:

> 中间件对组件产生了依赖的话，其他模块也需要耦合中间层才能发起调用。这样还是存在之前的相互耦合的问题，而且本质上比之前更麻烦了。

![只有单向依赖的组件化之后的项目依赖关系](http://upload-images.jianshu.io/upload_images/2015365-abf3332051cb854c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

对于中间件的设计方案，目前国内讨论比较火热的就两种。一是蘑菇街limboy大神的[URLRoute+Procotol](http://limboy.me/tech/2016/03/10/mgj-components.html)，另一种则是casatwy大神的[Target-Action](http://casatwy.com/iOS-Modulization.html)。我对这两种方案的归纳如下：

相同点：

1. 这两种中间件方案都实现了组件对中间件单向依赖
2. 结构基本一致，都将业务分成了`调用方`、`中间件`和`服务方`

不同点:

**服务方响应调用方的实现方式不同**

`URLRoute+Procotol`：

1. 需要注册组件，通过注册组件使得服务方可以被中间件发现
2. 调用方通过`URL`调用服务方页面，`URL`和服务方页面的关系通过`路由表`映射，路由表需要人工维护(硬编码)，使用持续集成环境简化操作
3. 调用方通过`Procotol`调用非页面类服务组件，可以传递复杂对象

`Target-Action`：

1. 不需要注册组件，通过runtime+约定命名规范(硬编码)的方式查找服务方
2. 区分本地调用和远程调用，本地调用通过`Target-Action`获取服务，同时为远程调用提供服务，远程调用的规则需约定好
3. 参数传递统一用Dictionary实现，获取Dictionary内所需要的内容需要通过文档或者其他说明
4. 通过category的形式拆分中间件的代码，使其分属不同组件

这两种方式谁优谁劣不好直接做判断，综合来看`URLRoute+Procotol`更适用于页面跳转这种业务较多的场景，同时配合持续集成环境，动态性更好(通过文本信息配置代替代码)，缺点是调用关系复杂，中间层比较庞大，需要配合持续集成环境才能有比较好的使用体验；`Target-Action`则更适合业务较杂的情况，核心代码很少，调用关系相对简单，缺点是硬编码场景较多，不过硬编码基本都在中间件里。

由于`URLRoute+Procotol`更适合有完整系统支持的场景，因此我们采用了`Target-Action`。该模式的特点也被充分验证：中间层代码量少、对项目的侵入性低，因此很快我们就完整组件化的工作了。

[下一篇](https://wangshiyu13.github.io/2017/01/11/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5(%E4%BA%8C)-%E5%87%86%E5%A4%87.html)将介绍我们组件化的具体过程，以及需要做的准备工作。


# 参考文章
[念纪-模块化与解耦](https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/)

[limboy-蘑菇街组件化之路](http://limboy.me/tech/2016/03/10/mgj-components.html)

[limboy-蘑菇街组件化之路-续](http://limboy.me/tech/2016/03/14/mgj-components-continued.html)

[Casa Taloyum-iOS应用架构谈-组件化方案](http://casatwy.com/iOS-Modulization.html)

[Skyline75489-浅析iOS应用组件化设计](http://skyline75489.github.io/post/2016-3-16_ios_module_design.html)

[philon-iOS组件化思路-大神博客研读和思考](http://www.jianshu.com/p/afb9b52143d4)

[philon-iOS组件化实践方案-LDBusMediator练就](http://www.jianshu.com/p/196f66d31543)

[bang-iOS组件化方案探索](http://blog.cnbang.net/tech/3080/)

[携程移动端架构演进与优化之路](http://weibo.com/ttarticle/p/show?id=2309404032668823108689)

[iOS-组件化架构漫谈](http://www.cnblogs.com/oc-bowen/p/5885476.html)